[Home](README.md) | [Why](why.md) | **[Pillars](pillars.md)** | [Systems](systems.md) | [Team](team-model.md)

# Software Planning and Development

The **Software Planning and Development** pillar is the engine room of the Released Method. It follows a structured, agile-aligned lifecycle designed to ship working software at a consistent cadence â€” while staying flexible enough to respond to change.

Built around iterative **sprints**, the process focuses on delivering functional, tested, and valuable software at every step. It promotes collaboration, innovation, and a relentless focus on the end-user.

---

## Agile Alignment

The Released Method adheres to the principles of the [Agile Manifesto](https://agilemanifesto.org/) â€” valuing individuals, interactions, working software, customer collaboration, and responding to change.

It aims to:

- Prioritise customer outcomes  
- Embrace evolving requirements  
- Sustain a consistent, manageable delivery pace  
- Foster tight alignment between business and development teams

Agile isnâ€™t a label here â€” itâ€™s embedded in how planning, building, and delivery actually happens.

---

## Sprint Structure

Sprints are **time-boxed iterations** (usually 1â€“4 weeks), each designed to produce a potentially shippable increment of the product. Every sprint includes structured activities from across the full lifecycle â€” from ideation to validation.

At the end of each sprint, the team should be able to demonstrate *real, working software*, not just progress or plans.

---

## Lifecycle Phases

The Released Method incorporates four key phases in every sprint cycle. These arenâ€™t linear â€” they loop and adapt as needed:

---

### 1. **Envision**

This is where ideas are born and refined into actionable hypotheses.

- **Brainstorm** â€“ Free-thinking, collaborative idea generation  
- **Hypothesis** â€“ Formulate possible solutions to user problems  
- **Wild Ideas** â€“ Deliberately stretch beyond the obvious  

ðŸ’¡ **Output**: A structured set of GitHub issues, split into:
- Functional requirements  
- Non-functional requirements  
- Prioritised backlogs  

---

### 2. **Prototype**

Validate assumptions before committing to full-scale development.

- **Build** â€“ Rapid prototype creation  
- **Verify** â€“ Quick user testing and validation  
- **Fail Fast** â€“ Kill bad ideas early and learn quickly  

Customer feedback is key here â€” the goal is real-world input, not perfection.

---

### 3. **Architect**

This is where ideas become product.

- **Develop** â€“ Turn validated prototypes into robust, secure features  
- **Document** â€“ Capture how features work and why they exist  
- **Refine** â€“ Improve design, performance, and structure  

Architecture doesnâ€™t mean heavyweight planning. It means thoughtful, scalable design from the ground up.

---

### 4. **Validate**

Final phase to ensure whatâ€™s built is fit for purpose.

- **Validate** â€“ Test against specs, edge cases, and business goals  
- **Optimize** â€“ Improve code performance, efficiency, and clarity  
- **Enhance** â€“ Apply feedback to raise the quality bar  

Every sprint should result in validated, production-ready work â€” not "works on my machine" builds.

---

## Sprint Execution in the Released Method

Each sprint incorporates **all four phases** to maintain momentum, encourage feedback loops, and support continuous improvement. This makes each sprint a mini product cycle, ensuring:

- Balanced workloads  
- Regular customer checkpoints  
- Ongoing technical excellence  
- No dead sprints or pointless refactoring loops  

Key ceremonies include:

- **Sprint Planning** â€“ What are we solving, and how?  
- **Stand-ups** â€“ Daily alignment and block removal  
- **Reviews/Demos** â€“ Show, donâ€™t tell â€” real work, real value  
- **Retrospectives** â€“ Improve the process, not just the product

---

## Final Word

The Software Planning and Development pillar is where strategy becomes execution. It blends agility with rigour, creativity with accountability, and iteration with direction.

It ensures your team doesnâ€™t just *write code* â€” it delivers working, tested, valuable software that evolves with your users and your business.